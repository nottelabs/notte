---
title: Batch Agents
description: Run multiple agents in parallel for improved success rates and throughput
---

import BatchAgent from "/snippets/agents/batch_agent.mdx";
import SuccessRateCalc from "/snippets/agents/batch/success_rate_calc.mdx";
import TimeToSuccess from "/snippets/agents/batch/time_to_success.mdx";
import FirstSuccessStrategy from "/snippets/agents/batch/first_success_strategy.mdx";
import AllFinishedStrategy from "/snippets/agents/batch/all_finished_strategy.mdx";
import SessionParams from "/snippets/agents/batch/session_params.mdx";
import NJobs from "/snippets/agents/batch/n_jobs.mdx";
import AgentParams from "/snippets/agents/batch/agent_params.mdx";
import UnreliablePages from "/snippets/agents/batch/unreliable_pages.mdx";
import RateLimitedSites from "/snippets/agents/batch/rate_limited_sites.mdx";
import AbTesting from "/snippets/agents/batch/ab_testing.mdx";
import ConsensusResults from "/snippets/agents/batch/consensus_results.mdx";
import ExecutionTime from "/snippets/agents/batch/execution_time.mdx";
import Cost from "/snippets/agents/batch/cost.mdx";
import StartWithParallel from "/snippets/agents/batch/start_with_parallel.mdx";
import CriticalTasks from "/snippets/agents/batch/critical_tasks.mdx";
import MonitorSuccessRates from "/snippets/agents/batch/monitor_success_rates.mdx";
import AppropriateStrategy from "/snippets/agents/batch/appropriate_strategy.mdx";
import Timeout from "/snippets/agents/batch/timeout.mdx";
import ConcurrencyLimits from "/snippets/agents/batch/concurrency_limits.mdx";
import CostScaling from "/snippets/agents/batch/cost_scaling.mdx";
import AsyncOnly from "/snippets/agents/batch/async_only.mdx";

Batch Agents execute multiple agent instances in parallel, either returning the first successful result or collecting all results.

## Overview

Run multiple agents concurrently with different strategies:

<BatchAgent />

## Why Use Batch Agents?

### Improved Success Rate

Agents can fail due to:
- Timing issues
- Random page behavior
- Rate limiting
- Network issues

Running multiple attempts in parallel increases success probability:

<SuccessRateCalc />

### Faster Time-to-Success

Return as soon as any agent succeeds:

<TimeToSuccess />

## Strategies

### First Success

Return immediately when any agent succeeds:

<FirstSuccessStrategy />

**When to use:**
- Non-deterministic pages
- Tasks prone to failures
- Time-sensitive operations
- You only need one successful result

### All Finished

Wait for all agents to complete:

<AllFinishedStrategy />

**When to use:**
- Comparing agent outputs
- Gathering multiple perspectives
- Testing different approaches
- Statistical analysis

## Configuration

### Session Parameters

Batch agents create multiple sessions with the same configuration:

<SessionParams />

### Number of Jobs

Control parallelism with `n_jobs`:

```python
# Light parallelism (2-3 agents)
result = await batch_agent.run(task="Task", n_jobs=2)

# Medium parallelism (3-5 agents)
result = await batch_agent.run(task="Task", n_jobs=5)

# Heavy parallelism (5-10 agents)
result = await batch_agent.run(task="Task", n_jobs=10)
```

**Cost consideration:** Each agent incurs full costs, so `n_jobs=5` costs 5x a single agent.

### Agent Parameters

Pass any agent parameter:

```python
batch_agent = BatchRemoteAgent(
    session=session,
    reasoning_model="anthropic/claude-3.5-sonnet",
    max_steps=20,
    use_vision=True,
    vault=vault,
    persona=persona,
    _client=client
)
```

## Use Cases

### 1. Unreliable Pages

Pages with random failures:

```python
# Page sometimes has timing issues
with client.Session() as session:
    batch_agent = BatchRemoteAgent(
        session=session,
        max_steps=10,
        _client=client
    )

    # Run 3 attempts
    result = await batch_agent.run(
        task="Click the submit button that appears after 2 seconds",
        n_jobs=3,
        strategy="first_success"
    )

    # Much higher success rate than single agent
```

### 2. Rate-Limited Sites

Avoid rate limit failures:

```python
# Some agents might get rate limited
with client.Session(proxies="residential") as session:
    batch_agent = BatchRemoteAgent(
        session=session,
        max_steps=15,
        _client=client
    )

    # Run 5 agents from different IPs
    result = await batch_agent.run(
        task="Extract product data",
        n_jobs=5,
        strategy="first_success"
    )
```

### 3. A/B Testing

Test which model works best:

```python
# Test different models
models = [
    "gemini/gemini-2.0-flash",
    "anthropic/claude-3.5-sonnet",
    "openai/gpt-4o"
]

results = []
for model in models:
    batch_agent = BatchRemoteAgent(
        session=session,
        reasoning_model=model,
        _client=client
    )

    result = await batch_agent.run(
        task="Complex task",
        n_jobs=3,
        strategy="first_success"
    )

    results.append({
        "model": model,
        "success": result.success,
        "steps": len(result.steps)
    })

# Compare which model performed best
```

### 4. Consensus Results

Get multiple agent opinions:

```python
batch_agent = BatchRemoteAgent(
    session=session,
    max_steps=10,
    _client=client
)

# Get results from all agents
results = await batch_agent.run(
    task="Extract the company's revenue",
    n_jobs=5,
    strategy="all_finished"
)

# Find consensus
revenues = [r.answer for r in results if r.success]
consensus = max(set(revenues), key=revenues.count)
```

## Performance

### Execution Time

With `first_success` strategy:

```python
# Single agent: 40 seconds average
# Batch of 3: ~13 seconds (first success)
# Speedup: ~3x faster for successful case
```

### Cost

Batch agents cost more:

```python
# Single agent: $0.02
# Batch of 3: $0.06 (3x cost)
# Batch of 5: $0.10 (5x cost)

# But: Higher success rate means fewer retries
```

### Success Rate

Probability of at least one success:

| Single Agent Success | 2 Parallel | 3 Parallel | 5 Parallel |
|---------------------|------------|------------|------------|
| 50% | 75% | 87.5% | 96.9% |
| 70% | 91% | 97.3% | 99.8% |
| 80% | 96% | 99.2% | 99.97% |

## Best Practices

### 1. Start with 2-3 Parallel Agents

Balance cost and reliability:

```python
# Good starting point
result = await batch_agent.run(
    task="Task with ~70% success rate",
    n_jobs=3,  # 97% combined success
    strategy="first_success"
)
```

### 2. Use for Critical Tasks

Worth the cost for important operations:

```python
# Critical: Use batch
with client.Session() as session:
    batch_agent = BatchRemoteAgent(session=session, _client=client)
    result = await batch_agent.run(
        task="Process payment",
        n_jobs=3
    )

# Non-critical: Use single agent
agent = client.Agent(session=session)
result = agent.run(task="Nice-to-have data")
```

### 3. Monitor Success Rates

Track if batch execution is needed:

```python
import asyncio

# Test single agent success rate
successes = 0
for _ in range(10):
    result = agent.run(task="Test task")
    if result.success:
        successes += 1

success_rate = successes / 10

if success_rate < 0.8:
    # Use batch for low success rates
    batch_agent = BatchRemoteAgent(session=session, _client=client)
    result = await batch_agent.run(task="Test task", n_jobs=3)
```

### 4. Use Appropriate Strategy

Choose based on your needs:

```python
# Need one good result quickly
strategy="first_success"

# Need to compare multiple results
strategy="all_finished"

# Need statistical confidence
strategy="all_finished"
```

### 5. Set Reasonable Timeouts

Prevent hanging:

```python
async def run_with_timeout():
    batch_agent = BatchRemoteAgent(session=session, _client=client)

    try:
        result = await asyncio.wait_for(
            batch_agent.run(task="Task", n_jobs=3),
            timeout=120  # 2 minute timeout
        )
        return result
    except asyncio.TimeoutError:
        print("Batch execution timed out")
        raise

result = await run_with_timeout()
```

## Limitations

### Resource Usage

Batch agents consume more resources:

- **Sessions**: Creates n separate sessions
- **Browsers**: Opens n browser instances
- **Memory**: n times single agent memory
- **API calls**: n times single agent calls

### Concurrency Limits

Account for rate limits:

```python
# May hit account concurrency limit
result = await batch_agent.run(
    task="Task",
    n_jobs=20  # Might exceed concurrent session limit
)

# Safer approach
result = await batch_agent.run(
    task="Task",
    n_jobs=5  # Within typical limits
)
```

### Cost Scaling

Costs multiply with `n_jobs`:

```python
# Single agent task: $0.02
# n_jobs=3: $0.06
# n_jobs=10: $0.20

# Use batch only when success rate justifies cost
```

## Async Only

Batch agents require async execution:

```python
import asyncio

async def run_batch():
    batch_agent = BatchRemoteAgent(session=session, _client=client)
    result = await batch_agent.run(task="Task", n_jobs=3)
    return result

# Must use asyncio.run
result = asyncio.run(run_batch())

# Or in async context
result = await run_batch()
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Lifecycle" icon="rotate" href="/features/agents/lifecycle">
    Understand agent execution modes
  </Card>

  <Card title="Configuration" icon="sliders" href="/features/agents/configuration">
    Configure agent parameters
  </Card>

  <Card title="Best Practices" icon="lightbulb" href="/guides/reliability">
    Build reliable automations
  </Card>

  <Card title="Pricing" icon="dollar-sign" href="/pricing">
    Understand cost implications
  </Card>
</CardGroup>
