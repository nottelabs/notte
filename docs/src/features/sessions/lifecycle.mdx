---
title: Session Lifecycle
description: Manage the lifecycle of your Notte browser sessions
---

Every Notte session follows a predictable lifecycle from creation to termination. Understanding this lifecycle helps you build reliable automation workflows and manage resources effectively.

## Session States

Sessions transition through these states:

* **`active`** - Session is running and ready to accept operations
* **`closed`** - Session has been terminated normally
* **`error`** - Session encountered an error and terminated unexpectedly
* **`timed_out`** - Session exceeded its timeout duration

## Creating a Session

Create a new session using the context manager pattern (recommended):

<CodeGroup>
  ```python Python - Context Manager
  from notte_sdk import NotteClient

  client = NotteClient()

  # Recommended: Use context manager for automatic cleanup
  with client.Session(
      headless=True,
      timeout_minutes=10,
      viewport_width=1920,
      viewport_height=1080
  ) as session:
      print(f"Session {session.session_id} is active")

      # Access Playwright page
      page = session.page
      page.goto("https://example.com")
      print(f"Page title: {page.title()}")

  # Session automatically stopped here
  ```

  ```python Python - Manual Management
  from notte_sdk import NotteClient

  client = NotteClient()

  # Manual management (not recommended)
  session = client.Session(timeout_minutes=10)
  session.start()

  try:
      print(f"Session {session.session_id} is active")
      page = session.page
      page.goto("https://example.com")
  finally:
      # Always stop the session
      session.stop()
  ```
</CodeGroup>

<Tip>
  Always use the context manager (`with` statement) to ensure sessions are properly stopped, even if errors occur.
</Tip>

## Getting Session Details

Retrieve current information about your session:

<CodeGroup>
  ```python Python
  from notte_sdk import NotteClient

  client = NotteClient()

  with client.Session() as session:
      # Get full session status
      status = session.status()

      print(f"Session ID: {status.session_id}")
      print(f"Status: {status.status}")
      print(f"Created at: {status.created_at}")
      print(f"Last accessed: {status.last_accessed_at}")
      print(f"Timeout: {status.timeout_minutes} minutes")
      print(f"Duration: {status.duration}")

      # Get CDP URL for external connections
      cdp_url = session.cdp_url()
      print(f"CDP WebSocket: {cdp_url}")
  ```
</CodeGroup>

<ResponseField name="session_id" type="string">
  Unique identifier for the session
</ResponseField>

<ResponseField name="status" type="string">
  Current status: `active`, `closed`, `error`, or `timed_out`
</ResponseField>

<ResponseField name="created_at" type="datetime">
  Session creation timestamp
</ResponseField>

<ResponseField name="closed_at" type="datetime | None">
  Session closure timestamp (None if still active)
</ResponseField>

<ResponseField name="last_accessed_at" type="datetime">
  Last operation timestamp
</ResponseField>

<ResponseField name="timeout_minutes" type="integer">
  Session timeout in minutes
</ResponseField>

<ResponseField name="duration" type="timedelta">
  Total session duration
</ResponseField>

## Listing Sessions

Query all your active sessions:

<CodeGroup>
  ```python Python
  from notte_sdk import NotteClient

  client = NotteClient()

  # List all sessions
  sessions = client.sessions.list()
  print(f"Total sessions: {len(sessions)}")

  for session in sessions:
      print(f"- {session.session_id} ({session.status})")
      print(f"  Created: {session.created_at}")
      print(f"  Duration: {session.duration}")

  # Filter by status
  active_sessions = client.sessions.list(status="active")
  print(f"Active sessions: {len(active_sessions)}")
  ```
</CodeGroup>

## Stopping a Session

Sessions are automatically stopped when using the context manager, but you can also stop them manually:

<CodeGroup>
  ```python Python
  from notte_sdk import NotteClient

  client = NotteClient()

  # Manual stop
  session = client.Session()
  session.start()

  # ... do work ...

  session.stop()
  print("Session stopped successfully")
  ```
</CodeGroup>

<Tip>
  Stopping a session is idempotent - you can safely call it multiple times without errors.
</Tip>

## Complete Lifecycle Example

Here's a complete example demonstrating best practices for session management:

<CodeGroup>
  ```python Python
  from notte_sdk import NotteClient
  import time

  client = NotteClient()

  def run_automation():
      # 1. Create session with configuration
      print("Creating session...")

      with client.Session(
          headless=False,  # Opens live viewer
          timeout_minutes=10,
          cookie_file="cookies.json"  # Auto-load/save cookies
      ) as session:
          print(f"Session created: {session.session_id}")
          print("Live viewer opened in browser")

          # 2. Access Playwright page
          page = session.page

          # 3. Use the session
          print("Navigating to example.com...")
          page.goto("https://example.com")

          title = page.title()
          print(f"Page title: {title}")

          # Take a screenshot
          page.screenshot(path="screenshot.png")
          print("Screenshot saved")

          # Wait before closing
          time.sleep(3)

          # Cookies automatically saved to cookies.json
          print("Session will be stopped and cookies saved...")

      # Session automatically stopped here
      print("Session stopped successfully")

  if __name__ == "__main__":
      run_automation()
  ```
</CodeGroup>

## Automatic Timeout

Sessions automatically close after a period of inactivity. The default timeout is 3 minutes, but you can configure it up to 30 minutes:

<CodeGroup>
  ```python Python
  from notte_sdk import NotteClient

  client = NotteClient()

  # Set custom timeout (1-30 minutes)
  with client.Session(timeout_minutes=15) as session:
      page = session.page
      page.goto("https://example.com")

      # Session will automatically close after 15 minutes of inactivity
  ```
</CodeGroup>

<Warning>
  Don't rely solely on automatic timeouts. Always explicitly stop sessions using the context manager or `session.stop()` to avoid unexpected resource usage.
</Warning>

## Connecting to Existing Sessions

You can reconnect to an existing session using its session_id:

<CodeGroup>
  ```python Python
  from notte_sdk import NotteClient

  client = NotteClient()

  # Connect to existing session
  session_id = "550e8400-e29b-41d4-a716-446655440000"

  with client.Session(session_id) as session:
      print(f"Connected to session: {session.session_id}")

      # Get current status
      status = session.status()
      print(f"Session status: {status.status}")

      # Continue using the session
      page = session.page
      page.goto("https://example.com")
  ```
</CodeGroup>

## Error Handling

The context manager automatically handles cleanup, even when errors occur:

<CodeGroup>
  ```python Python - Automatic Cleanup
  from notte_sdk import NotteClient

  client = NotteClient()

  try:
      with client.Session() as session:
          page = session.page
          page.goto("https://example.com")

          # Simulate an error
          raise ValueError("Something went wrong!")

  except ValueError as e:
      print(f"Automation failed: {e}")
      # Session is still automatically stopped

  print("Session was cleaned up despite the error")
  ```

  ```python Python - Manual Error Handling
  from notte_sdk import NotteClient

  client = NotteClient()

  session = None

  try:
      session = client.Session()
      session.start()

      page = session.page
      page.goto("https://example.com")

      # Your automation code here

  except Exception as error:
      print(f"Automation failed: {error}")
  finally:
      # This always runs, whether success or failure
      if session is not None:
          session.stop()
          print("Session stopped")
  ```
</CodeGroup>

## Cookie Persistence

Automatically persist cookies across sessions for maintaining authentication:

<CodeGroup>
  ```python Python - Automatic Persistence
  from notte_sdk import NotteClient

  client = NotteClient()

  # Cookies automatically loaded at start and saved at stop
  with client.Session(cookie_file="auth_cookies.json") as session:
      page = session.page
      page.goto("https://example.com/login")

      # Log in, cookies are automatically captured
      page.fill('input[name="email"]', "user@example.com")
      page.fill('input[name="password"]', "password")
      page.click('button[type="submit"]')

      # Cookies automatically saved when session ends

  # Next time, cookies are automatically loaded
  with client.Session(cookie_file="auth_cookies.json") as session:
      page = session.page
      page.goto("https://example.com/dashboard")
      # Already logged in!
  ```

  ```python Python - Manual Cookie Management
  from notte_sdk import NotteClient
  import json

  client = NotteClient()

  with client.Session() as session:
      page = session.page
      page.goto("https://example.com")

      # Get cookies manually
      cookies = session.get_cookies()
      with open("cookies.json", "w") as f:
          json.dump(cookies, f)

  # Later session: load cookies manually
  with client.Session() as session:
      with open("cookies.json", "r") as f:
          cookies = json.load(f)
      session.set_cookies(cookies=cookies)

      page = session.page
      page.goto("https://example.com")
  ```
</CodeGroup>

## Session Viewer

Monitor your sessions in real-time:

<CodeGroup>
  ```python Python - Auto-open Viewer
  from notte_sdk import NotteClient

  client = NotteClient()

  # Viewer opens automatically when headless=False
  with client.Session(headless=False) as session:
      page = session.page
      page.goto("https://example.com")
      # Watch the automation in your browser
  ```

  ```python Python - Manual Viewer Control
  from notte_sdk import NotteClient

  client = NotteClient()

  with client.Session(headless=True) as session:
      # Open viewer manually
      session.viewer()  # Opens in browser

      # Or open CDP debugger
      session.viewer_cdp()

      # Or for Jupyter notebooks
      session.viewer_notebook()

      page = session.page
      page.goto("https://example.com")
  ```
</CodeGroup>

## Connect with External Browsers

Use Notte sessions with external browser providers:

<CodeGroup>
  ```python Python - Kernel.sh Integration
  from notte_sdk import NotteClient
  from kernel import Kernel

  notte = NotteClient()
  kernel = Kernel()

  # Create browser on Kernel
  kernel_browser = kernel.browsers.create()

  # Connect Notte to Kernel's browser
  with notte.Session(cdp_url=kernel_browser.cdp_ws_url) as session:
      page = session.page
      page.goto("https://example.com")

      # Session still benefits from Notte's features:
      # - observe() and execute() actions
      # - scrape() for data extraction
      # - Agent integration
  ```

  ```python Python - Direct CDP Connection
  from notte_sdk import NotteClient
  from playwright.sync_api import sync_playwright

  notte_client = NotteClient()

  with notte_client.Session() as session:
      # Get CDP URL for external connection
      cdp_url = session.cdp_url()

      # Connect external Playwright instance
      with sync_playwright() as p:
          browser = p.chromium.connect_over_cdp(cdp_url)
          page = browser.contexts[0].pages[0]

          page.goto("https://example.com")
          print(page.title())
  ```
</CodeGroup>

## Best Practices

Follow these patterns to build reliable, cost-effective automation:

### 1. Always Use Context Managers

The `with` statement guarantees cleanup:

```python
with client.Session() as session:
    # ... use session
# Automatically stopped here
```

### 2. Set Appropriate Timeouts

Match timeout to task duration with a buffer for delays:

* **Quick tasks**: 3-5 minutes (default is 3)
* **Data scraping**: 10-15 minutes
* **Long workflows**: 20-30 minutes

```python
with client.Session(timeout_minutes=15) as session:
    # Complex automation
    pass
```

### 3. Use Cookie Persistence for Auth

Avoid repeated logins by persisting cookies:

```python
with client.Session(cookie_file="cookies.json") as session:
    # Cookies auto-loaded and auto-saved
    pass
```

### 4. Monitor Session State

Check session status before long-running operations:

```python
with client.Session() as session:
    status = session.status()
    if status.status != 'active':
        raise Exception('Session is no longer active')

    # Continue with operations
```

### 5. Handle Cleanup Gracefully

Even with context managers, handle interrupts:

```python
import signal
import sys

def signal_handler(sig, frame):
    print('Interrupt received, cleaning up...')
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)

with client.Session() as session:
    # Your automation
    pass
```

### 6. Use Session Replay for Debugging

Review sessions after completion:

```python
with client.Session() as session:
    page = session.page
    page.goto("https://example.com")
    # ... automation

# After session ends, get replay
replay = session.replay()
replay.save("session_recording.mp4")
```

### 7. Leverage File Storage for Downloads

Integrate file storage for handling uploads/downloads:

```python
storage = client.FileStorage()

with client.Session(storage=storage) as session:
    page = session.page
    page.goto("https://example.com/download")

    # Files automatically available in storage
    files = storage.list_downloaded_files()
```

## Session Lifecycle Diagram

```
┌─────────────────────────────────────────────────────────┐
│ 1. CREATE                                               │
│    session = client.Session(timeout_minutes=10)         │
│    Status: Not started (response = None)                │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 2. START                                                │
│    with session: / session.start()                      │
│    Status: active                                       │
│    - Creates remote browser                             │
│    - Opens viewer if headless=False                     │
│    - Loads cookies from cookie_file                     │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 3. ACTIVE OPERATIONS                                    │
│    - session.execute(action)                            │
│    - session.observe()                                  │
│    - session.scrape()                                   │
│    - session.page.goto(url)                             │
│    Status: active                                       │
└────────────────────┬────────────────────────────────────┘
                     │
            ┌────────┴────────┐
            ▼                 ▼
┌──────────────────┐  ┌──────────────────┐
│ 4a. TIMEOUT      │  │ 4b. STOP         │
│ (after N mins)   │  │ session.stop()   │
│ Status: timed_out│  │ Status: closed   │
└──────────────────┘  └──────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 5. CLEANUP                                              │
│    - Saves cookies to cookie_file                       │
│    - Closes Playwright connections                      │
│    - Releases cloud resources                           │
└─────────────────────────────────────────────────────────┘
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Session Configuration" icon="gear" href="/features/sessions/configuration">
    Configure sessions with advanced options
  </Card>

  <Card title="Session Replay" icon="video" href="/features/sessions/session-replay">
    Record and replay session activity
  </Card>

  <Card title="CDP Integration" icon="code" href="/features/sessions/cdp">
    Connect Playwright or Puppeteer directly
  </Card>

  <Card title="Cookie Management" icon="cookie-bite" href="/features/sessions/cookies">
    Persist authentication across sessions
  </Card>
</CardGroup>
