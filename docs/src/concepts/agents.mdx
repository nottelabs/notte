---
title: Browser Agents
description: AI-powered agents that autonomously complete browser tasks
---

import AgentQuickstart from "/snippets/agents/quickstart.mdx";

Browser Agents are AI-powered systems that can autonomously navigate websites, complete tasks, and extract information using natural language instructions.

## What is a Browser Agent?

A Browser Agent combines:
- **Large Language Models (LLMs)** for reasoning and decision-making
- **Browser Sessions** for executing actions
- **Vision capabilities** to understand web pages
- **Autonomous planning** to complete multi-step tasks

Unlike scripted automation, agents can adapt to changes, handle unexpected scenarios, and complete tasks without predefined workflows.

## Quick Start

Create and run an agent in a few lines:

<AgentQuickstart />

## How Agents Work

### 1. Observation

The agent observes the current page state:
- Visible elements and their properties
- Interactive components (buttons, forms, links)
- Text content and structure
- Current URL and page metadata

### 2. Reasoning

Using the LLM, the agent:
- Understands the current page
- Plans the next action to complete the task
- Decides which element to interact with
- Determines when the task is complete

### 3. Action

The agent executes browser actions:
- Navigate to URLs
- Click buttons and links
- Fill forms
- Extract data
- Scroll and interact with dynamic content

### 4. Iteration

This cycle repeats until:
- The task is successfully completed
- Maximum steps are reached
- An error occurs that can't be resolved

## Agents vs Scripted Automation

Both agents and scripted automation run on [browser sessions](/concepts/sessions)â€”the cloud browser infrastructure. The difference is how you control what happens in that session.

| Aspect | Scripted Automation | Agent |
|--------|---------------------|-------|
| **Control** | You write the code | AI decides each step |
| **Flexibility** | Fixed workflow | Adapts to changes |
| **Speed** | Fast (direct execution) | Slower (LLM reasoning per step) |
| **Cost** | Browser minutes only | Browser minutes + LLM calls |
| **Reliability** | Deterministic | Can vary based on page state |
| **Use Case** | Known, stable workflows | Unknown or dynamic workflows |

**Use scripted automation when:**
- You know the exact steps to take
- Speed and cost are critical
- The target pages rarely change

**Use agents when:**
- You don't know the exact steps
- Pages change frequently
- You need intelligent decision-making

<Note>
  You can combine both approaches: use an agent to figure out a workflow, then [convert it to a function](/features/agents/workflows) for faster, cheaper repeated execution.
</Note>

## Key Features

### Natural Language Tasks

Give instructions in plain English:

```python
agent.run(task="Find the cheapest laptop under $1000 and add it to cart")
```

### Structured Output

Get responses in a specific format:

```python
from pydantic import BaseModel

class ContactInfo(BaseModel):
    email: str
    phone: str | None

result = agent.run(
    task="Extract contact information",
    response_format=ContactInfo
)
```

### Starting URL

Begin at a specific page:

```python
agent.run(
    task="Find pricing information",
    url="https://example.com/products"
)
```

### Step Limits

Control maximum actions:

```python
agent = client.Agent(
    session=session,
    max_steps=20  # Limit to 20 actions
)
```

## Agent Lifecycle

Agents support multiple execution modes:

### Run (Blocking)

Start and wait for completion:

```python
result = agent.run(task="Complete the task")
```

### Start + Wait (Non-blocking)

Start and wait separately:

```python
agent.start(task="Complete the task")
# Do other work...
result = agent.wait()
```

### Status Monitoring

Check progress at any time:

```python
agent.start(task="Long running task")
status = agent.status()
print(f"Completed {len(status.steps)} steps")
```

## Best Practices

### 1. Be Specific

Clear tasks get better results:

```python
# Good
task = "Extract all product names and prices from the first page of results"

# Vague
task = "Get products"
```

### 2. Set Appropriate Step Limits

Match the complexity of your task:

```python
# Simple task
agent = client.Agent(session=session, max_steps=5)

# Complex multi-page task
agent = client.Agent(session=session, max_steps=30)
```

### 3. Use Vision When Needed

Enable vision for image-heavy sites:

```python
agent = client.Agent(
    session=session,
    use_vision=True  # Better understanding of visual content
)
```

### 4. Choose the Right Model

Balance cost and capability:

```python
# Fast and cheap
reasoning_model="gemini/gemini-2.0-flash"

# More capable
reasoning_model="anthropic/claude-3.5-sonnet"
```

## Error Handling

Agents can fail for various reasons:

```python
result = agent.run(task="Complete task")

if result.success:
    print(result.answer)
else:
    print(f"Agent failed: {result.error}")
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Configuration" icon="sliders" href="/features/agents/configuration">
    Learn about all agent parameters
  </Card>

  <Card title="Lifecycle" icon="rotate" href="/features/agents/lifecycle">
    Understand agent execution modes
  </Card>

  <Card title="Models" icon="brain" href="/features/agents/models">
    Choose the right reasoning model
  </Card>

  <Card title="Structured Output" icon="brackets-curly" href="/features/agents/structured-output">
    Get typed responses from agents
  </Card>
</CardGroup>
